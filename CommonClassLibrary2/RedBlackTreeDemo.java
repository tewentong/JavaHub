/*
    红黑树结构分析：
        二叉树的主要特点：数据查询的时候可以提供更好的查询性能，但是这中原始的二叉树的性能是有明显缺陷的
            例如：当二叉树结构改变的时候（增加或删除）就有可能出现不平衡的问题
                 之前所谓的解决二叉树性能问题的方式最终没有作用
                 也就是说，如果想要达到最好的二叉树，那么它首先应该是一个平衡二叉树，同时所有的节点的层次深度应该相同
                 如果二叉树按照以上的结构进行保存，那么二叉树检索操作的执行效率一定是最高的
                 可是，你的树需要忍受住这些频繁的增加或者是删除操作
                 所以针对于二叉树有了进一步的设计要求
        红黑树：本质上是一种二叉查找树，但它在二叉查找树的基础上额外增加了一个标记（颜色），同时具有一定的规则
               这些规则使红黑树保证了一种平衡、插入、删除、查找的最坏时间复杂度都为O(logn)
               红黑树的本质就是在节点上追加了一个表示颜色的操作信息而已
            对于Node节点中的颜色标记也可以使用true或false来实现，不一定非要使用枚举类
        红黑树的特点：
            1.每个节点或者是黑色，或者是红色
            2.根节点必须是黑色
            3.每个叶子节点是黑色
                Java实现的红黑树将使用null来代表空节点，因此遍历红黑树时将看不到黑色的叶子节点，反而看到每个叶子节点都是红色的
            4.如果一个节点是红色的，则它的子节点必须是黑色的
                从每个根到节点的路径上不会有两个连续的红色节点，但黑色节点可以是连续的
                若给定黑色节点的个数N，最短路径的情况是连续的N个黑色，树的高度为N-1
                最长路径的情况为节点红黑相间，书的高度为2(N-1)
            5.从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点数量
        成为红黑树的最主要的条件，后序的插入、删除操作都是为了遵守这个规定
        主要是利用红色节点与黑色节点实现均衡的控制。简单点理解红黑树的结构就是为了可以进行左旋和右旋控制以保证平衡性。
        但是对于平衡性还需要考虑数据增加的平衡以及数据删除的平衡，增加和删除都是需要对这棵树进行平衡修复。

        在进行红黑树处理的时候为了方便操作都会将新的节点使用红色来进行描述，于是当设置根节点的时候就会违反规则2，这个时候只需要将节点的颜色涂黑即可。

        在红黑树进行修复处理之中，它需要根据当前节点以及当前节点的父节点和叔叔节点之间的颜色来推断树是否需要修复处理。
        在红黑树之中修复的目的是为了保证树结构中的黑色节点的数量平衡。
            黑色节点的数量平衡了，才有可能得到O(logn)的执行性能
            但是修复的过程一方面是红黑的处理，另外一方面就是黑色子节点的保存层次
*/
enum Color {
    RED, BLACK;
}
class BinaryTree030602<T> {
    private class Node {
        private T data;
        private Node parent;
        private Node left;
        private Node right;
        private Color color;
    }
}
public class RedBlackTreeDemo {
    public static void main(String[] args) {

    }
}